LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
USE work.common_pack.ALL;
-- NOTES:
-- data_reg is not assigned to rxData 
--
ENTITY cmdProc IS
PORT (
    clk:          IN std_logic;
    reset:        IN std_logic;
    rxnow:        IN std_logic;
    rxData:       IN std_logic_vector (7 downto 0); -- Data input 
    txData:       OUT std_logic_vector (7 downto 0);
    rxdone:       OUT std_logic;
    ovErr:        IN std_logic;
    framErr:      IN std_logic;
    txnow:        OUT std_logic;
    txdone:       IN std_logic;
    start:        OUT std_logic;
    numWords_bcd: OUT BCD_ARRAY_TYPE(2 downto 0);
    dataReady:    IN std_logic;
    byte:         IN std_logic_vector(7 downto 0);
    maxIndex:     IN BCD_ARRAY_TYPE(2 downto 0);
    dataResults:  IN CHAR_ARRAY_TYPE(0 to RESULT_BYTE_NUM-1);
    seqDone:      IN std_logic
    );
END cmdProc;

ARCHITECTURE command OF cmdProc IS 
 
 -- STATE DECLARATION 
 TYPE STATE_TYPE IS (INIT, A, L, P, CHECK_NNN, ECHO, START, PRINT);
 SIGNAL curState, nextState: state_type;
 SIGNAL data_reg: std_logic_vector(7 DOWNTO 0) := x"00"; -- Added signal data_reg for input to remain steady for at least 1 clock cycle 
   

 -----------------------------------------------------   
  -- STATE REGISTERS 
  State_register: PROCESS (reset, clk)
  BEGIN
    IF reset = '1' THEN
      curState <= INIT;
    ELSIF clk'EVENT AND clk = '1' THEN 
      -- x_reg <= x;  
      curState <= nextState;
    END IF;
  END PROCESS;
 
 -----------------------------------------------------
  -- NEXT STATE LOGIC 
  nextStateLogic: PROCESS(curState, data_reg)
  BEGIN
  
    CASE curState IS
  
      WHEN INIT =>
        IF data_reg = x"41" OR data_reg = x"61" THEN -- Detects A or a
          nextState <= A;                            -- waits for NNN to be typed to the terminal
        
        ELSIF data_reg = x"50" OR data_reg = x"70" THEN -- Detects P or p
          nextState <= P;
        
        ELSIF data_reg = x"4C" OR data_reg = x"6C" THEN -- Detects L or l
          nextState <= L;
        
        ELSE -- If not A, P, or L
          nextState <= INIT;
        END IF;  
  
        
      WHEN A =>
        nextState <= ;
      
      WHEN L =>
        nextState <= ;
      
      WHEN P =>
        nextState <= ;
      
      WHEN CHECK_NNN =>
        nextState <= ;
  
      WHEN ECHO =>
        nextState <= ;

      WHEN START =>
        nextState <= ;
      
      WHEN PRINT =>
        nextState <= ;
    
      WHEN OTHERS => 
        nextState <= INIT;  -- Accounts for undefined states 
    
    END CASE;
  END PROCESS;
  
  -----------------------------------------------------

  -- NEXTSTATE OUTPUT LOGIC 
  ctrlOut: PROCESS(curState, data_reg)
  BEGIN
    -- assign default values
 
    CASE curState IS
      
      WHEN INIT =>
        nextState <= A;
 
      WHEN A =>
        nextState <= ;
      
      WHEN L =>
        nextState <= ;
      
      WHEN P =>
        nextState <= ;
      
      WHEN CHECK_NNN =>
        nextState <= ;
  
      WHEN ECHO =>
        nextState <= ;

      WHEN START =>
        nextState <= ;
      
      WHEN PRINT =>
        nextState <= ;
      
      WHEN OTHERS =>
   
   
    END CASE;
END PROCESS;
---------------------------------------------------
----L printing process
L: PROCESS(dataResults)
BEGIN
	IF dataReady = '1' THEN
		IF txDone <= 1 THEN
			txDone <= 0;
			data <= dataResults;
			txDone <= 1;
		ELSE
			WHILE txDone <= 0 THEN
				data <= 0;
			END
		dataRes_to_Hex()
		--dataResults to hexadecimal function
	ELSE IF seqDone = '1' THEN
		data <= dataResults;
		dataRes_to_Hex()
		--dataResults to hexadecimal function
	END IF
END PROCESS
--------------------------------------------------------------------------------------
--------- ASCII input from DP to hex output to Tx
FUNCTION dataRes_to_Hex()
	variable bin_num : integer range 0 to 15;
	
	Res1 <= unsigned(std_logic_vector(8 downto 0));
	Res2 <= unsigned(std_logic_vector(16 downto 9));
	Res3 <= unsigned(std_logic_vector(24 downto 17));
	Res4 <= unsigned(std_logic_vector(32 downto 25)); --seperating peak and 3 values before and after
	Res5 <= unsigned(std_logic_vector(40 downto 33));
	Res6 <= unsigned(std_logic_vector(48 downto 41));
	Res7 <= unsigned(std_logic_vector(56 downto 49));
	
	Res1_1 <= unsigned(std_logic_vector(4 downto 0)); --need a way to put this into a loop so code doesn't repeat
	Res1_2 <= unsigned(std_logic_vector(8 downto 5)); --split into 4 bits each
	
	bin_num := to_integer(unsigned(ascii_in));
	case bin_num is
      		WHEN 0 to 9   => 
			hex_out <= std_logic_vector(to_unsigned(bin_num, 4));
      		WHEN 10 to 15 => 
			hex_out <= std_logic_vector(to_unsigned(bin_num + 7, 4));
      		WHEN others  => 
			hex_out <= (others => '0');
    	end case;
	
 -- need spaces in between each byte
 -- after 8 bits add space
  
END; -- ARCHITECHTURE
      
      
  
  

  
  

 
  
  
  
  
  signal clk: std_logic := '0';
  signal reset, sig_start, ctrl_genDriv, ctrl_consDriv, sig_dataReady, sig_seqDone: std_logic;
  signal sig_rxDone, sig_rxNow, sig_ovErr, sig_framErr, sig_txNow, sig_txDone: std_logic;
  signal sig_rx, sig_tx, sig_rx_debug: std_logic;
  
  signal sig_rxData, sig_txData, sig_byte: std_logic_vector(7 downto 0);
  signal sig_maxIndex: BCD_ARRAY_TYPE(2 downto 0);
  
  signal sig_dataResults: CHAR_ARRAY_TYPE(0 to 6);
  signal sig_numWords_bcd: BCD_ARRAY_TYPE(2 downto 0);
  
  signal sig_data: std_logic_vector(7 downto 0);
    
  constant SEQ_COUNT_MAX : integer := 1; -- defines how many runs to test
  
  type ARRAY3D_TYPE is array (0 to SEQ_COUNT_MAX) of CHAR_ARRAY_TYPE(0 to RESULT_BYTE_NUM-1);
  type ARRAY3D_BCD_TYPE is array (0 to SEQ_COUNT_MAX) of BCD_ARRAY_TYPE(2 downto 0);
  type SEQUENCE_TYPE is array (integer range<> ) of CHAR_ARRAY_TYPE(1 to 2);
 
  constant sequence1 : SEQUENCE_TYPE(1 to 12) := (("00111001","00110101"),   --X"95"
                                                  ("00110001","00110011"),   --X"13"
                                                  ("00110110","00110000"),   --X"60"
                                                  ("00110000","00111001"),   --X"09"
                                                  ("00110110","00111000"),   --X"68"
                                                  ("01000001","00111000"),   --X"A8"
                                                  ("00111001","00110011"),   --X"93"
                                                  ("01000110","00111001"),   --X"F9"
                                                  ("00110111","00110001"),   --X"71"
                                                  ("01000011","00110111"),   --X"C7"
                                                  ("00111001","00110010"),   --X"92"
                                                  ("00110000","00110110")   --X"06"
                                                  );
   

