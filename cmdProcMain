LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
USE work.common_pack.ALL;
-- NOTES:
-- data_reg is not assigned to rxData (ASK TA IF ITS IMPLEMENTED CORRECTLY !!!)
--
ENTITY cmdProc IS
PORT (
    clk:          IN std_logic;
    reset:        IN std_logic;
    rxnow:        IN std_logic;
    rxData:       IN std_logic_vector (7 downto 0); -- Data input
    txData:       OUT std_logic_vector (7 downto 0);
    rxdone:       OUT std_logic;
    ovErr:        IN std_logic;
    framErr:      IN std_logic;
    txnow:        OUT std_logic;
    txdone:       IN std_logic;
    start:        OUT std_logic;
    numWords_bcd: OUT BCD_ARRAY_TYPE(2 downto 0);
    dataReady:    IN std_logic;
    byte:         IN std_logic_vector(7 downto 0);
    maxIndex:     IN BCD_ARRAY_TYPE(2 downto 0);
    dataResults:  IN CHAR_ARRAY_TYPE(0 to RESULT_BYTE_NUM-1);
    seqDone:      IN std_logic
    );
END cmdProc;

ARCHITECTURE command OF cmdProc IS
 
 -- STATE DECLARATION
 TYPE STATE_TYPE IS (INIT, RECEIVING,WAIT_NNN, WAIT_BYTES, EQUAL_NNN, RECEIVE_BYTES, TRANSMIT_BYTES, L_PRINT, P_PRINT, CHECK_NNN, START);
 SIGNAL curState, nextState: state_type;
 SIGNAL data_reg: std_logic_vector(7 DOWNTO 0); -- Added signal data_reg for input to remain steady for at least 1 clock cycle
 
 -- COUNTER SIGNALS  
 SIGNAL validCount: integer range 0 to 3;
 SIGNAL en_validCount, res_validCount: bit;
 
 SIGNAL dataReadyCount: integer range 0 to 999;
 SIGNAL res_dataReadyCount, en_dataReadyCount: bit;
 
 -- SIGNAL TO CHECK FOR NNN
 SIGNAL BOOL_N1, BOOL_N2, BOOL_N3: BOOLEAN := FALSE;
 
 SIGNAL L_array: CHAR_ARRAY_TYPE(0 to 20); -- CHECK IF DEFINED CORRECTLY !!!
 SIGNAL P_array: CHAR_ARRAY_TYPE(0 to 5);
-----------------------------------------------------  
  -- STATE REGISTERS
  State_register: PROCESS (reset, clk)
  BEGIN
    IF reset = '1' THEN
      curState <= INIT;
    ELSIF clk'EVENT AND clk = '1' THEN
      data_reg <= rxData;  
      curState <= nextState;
    END IF;
  END PROCESS;
-----------------------------------------------------
-- CONVERSIONS
byteToHex: PROCESS(byte)
BEGIN
  byte1 <= to_integer(unsigned(byte(7 DOWNTO 4))); -- CHECK IF YOU NEED TO DEFINE AS VARIABLES !!!
  byte2 <= to_integer(unsigned(byte(3 DOWNTO 0)));
   
  IF ((byte1 >= 0) OR ((byte2 >= 0) AND (byte1 <= 9)) OR (byte2 <= 9)) THEN
    byteOut1 <= '0011' & byte(7 DOWNTO 4);
    byteOut2 <= '0011' & byte(3 DOWNTO 0);

  ELSIF (byte1 >= 10) OR ((byte2 >= 10) AND (byte1 <= 15)) OR ((byte2 >= 15) THEN
    IF byte1 = 10`OR byte2 = 10 THEN
      byteOut1 <= ; X"41" -- A
      byteOut2 <= ; X"41" -- A
    ELSIF byte1 = 11`OR byte2 = 11 THEN
      byteOut1 <= ; X"42" -- B
      byteOut2 <= ; X"42" -- B
    ELSIF byte1 = 12`OR byte2 = 12 THEN
      byteOut1 <= ; X"43" -- C
      byteOut2 <= ; X"43" -- C
    ELSIF byte1 = 13`OR byte2 = 13 THEN
      byteOut1 <= ; X"44" -- D
      byteOut2 <= ; X"44" -- D
    ELSIF byte1 = 14`OR byte2 = 14 THEN
      byteOut1 <= ; X"45" -- E
      byteOut2 <= ; X"45" -- E
    ELSIF byte1 = 15`OR byte2 = 14 THEN
      byteOut1 <= ; X"46" -- F
      byteOut2 <= ; X"46" -- F
  END IF;
 
END PROCESS;

-----------------------------------------------------
-- ASCII input from DP to hex output to Tx
dataRes_to_Hex: PROCESS(Res_reg) -- CHECK SENSITIVITY LIST !!!
BEGIN    
  FOR i in 0 to 6 LOOP
     Res <= dataResults(i)
     data1 <= to_integer(Res(7 downto 4));
     data2 <= to_integer(Res(4 downto 0));
                
     IF ((data1 >= 0) OR ((data2 >= 0) AND (data1 <= 9)) OR (data2 <= 9)) THEN
       L_array(3i) <= '0011' & Res(7 DOWNTO 4);
       L_array(3i+1) <= '0011' & Res(3 DOWNTO 0);    
     
     ELSIF (data1 >= 10) OR ((data2 >= 10) AND (data1 <= 15)) OR ((data2 >= 15) THEN
      IF data1 = 10`OR data2 = 10 THEN
        L_array(3i) <= ; X"41" -- A
        L_array(3i+1) <= ; X"41" -- A
      ELSIF data1 = 11`OR data2 = 11 THEN
        L_array(3i) <= ; X"42" -- B
        L_array(3i+1) <= ; X"42" -- B
      ELSIF data1 = 12`OR data2 = 12 THEN
        L_array(3i) <= ; X"43" -- C
        L_array(3i+1) <= ; X"43" -- C
      ELSIF data1 = 13`OR data2 = 13 THEN
        L_array(3i) <= ; X"44" -- D
        L_array(3i+1) <= ; X"44" -- D
      ELSIF data1 = 14`OR data2 = 14 THEN
        L_array(3i) <= ; X"45" -- E
        L_array(3i+1) <= ; X"45" -- E
      ELSIF data1 = 15`OR data2 = 14 THEN
        L_array(3i) <= ; X"46" -- F
        L_array(3i+1) <= ; X"46" -- F
      END IF;
      END IF;
  END loop;
 
  FOR j in 1 to 7 LOOP
    L_array((3*j)-1) <= X"20"
  END loop;
END PROCESS;   
 
-----------------------------------------------------
-- COUNTERS
NNN_counter: PROCESS(reset, res_validCount, en_validCount, clk, rxnow)
BEGIN
  IF reset = '1' OR res_validCount = '1' THEN
      validCount <= 0;
 
  ELSIF clk'EVENT AND clk = '1' THEN
    IF en_validCount = '1' AND curState = WAIT_NNN THEN
      IF rxnow = '1' THEN
        validCount <= validCount + 1;
      ELSE
        validCount <= validCount;
      END IF;
    END IF;
  END IF;
END PROCESS;

dataReady_counter: PROCESS(reset, res_dataReadyCount, en_dataReadyCount, clk) -- CHECK IF YOU NEED TO ADD 'dataReady' CONDITION
BEGIN
  IF reset = '1' OR res_dataReadyCount = '1' THEN
      dataReadyCount <= 0;
  ELSIF clk'EVENT AND clk = '1' THEN
    IF en_dataReadyCount = '1' AND curState = RECEIVE_BYTES THEN
      dataReadyCount <= dataReadyCount + 1;
    ELSE
      dataReadyCount <= dataReadyCount;
    END IF;
  END IF;
END PROCESS;
 
-----------------------------------------------------
NNN_CHECK: PROCESS(validCount, clk)
BEGIN
  IF validCount = 1 THEN
    n1 <= data_reg;
  ELSIF validCount = 2 THEN
    n2 <= data_reg;
  ELSIF validCount = 3 THEN
    n3 <= data_reg;
  END IF;
     
  IF n1(7 DOWNTO 4) = '0011' AND n2(7 DOWNTO 4) = '0011' AND n3(7 DOWNTO 4) = '0011' THEN
    num1 <= to_integer(n1(3 DOWNTO 0));
    num2 <= to_integer(n2(3 DOWNTO 0));
    num3 <= to_integer(n3(3 DOWNTO 0));
       
    IF (num1 >= 0) AND (num2>= 0) AND (num3 >= 0) AND (num1<= 9) AND (num2<= 9) AND (num3<= 9) THEN
      numWords_bcd(0) <= n1(3 DOWNTO 0);
      numWords_bcd(1) <= n2(3 DOWNTO 0);
      numWords_bcd(2) <= n3(3 DOWNTO 0);
      NNN <= (num1*100) + (num2*10) + (num3);
      BOOL_N1 <= TRUE;
      BOOL_N2 <= TRUE;
      BOOL_N3 <= TRUE;
     
    ELSE
      numWords_bcd(0) <= "0000";
      numWords_bcd(1) <= "0000";
      numWords_bcd(2) <= "0000";
      BOOL_N1 <= FALSE;
      BOOL_N2 <= FALSE;
      BOOL_N3 <= FALSE;
      nextState <= INIT; -- REMOVE
  ELSE
    numWords_bcd(0) <= "0000";
    numWords_bcd(1) <= "0000";
    numWords_bcd(2) <= "0000";
    BOOL_N1 <= FALSE;
    BOOL_N2 <= FALSE;
    BOOL_N3 <= FALSE;
    nextState <= INIT; -- REMOVE
     
    END IF;
  END IF;
END PROCESS;
-----------------------------------------------------
-- DATA ECHOING PROCESS
inputEchoing: PROCESS(data_reg, clk, rxNow)
BEGIN
  IF rxNow = '1' THEN
    IF txDone = '1' THEN
        txNow = '0';
    ELSIF txDone = '0' THEN
        txNow = '1';
    END IF;
  END IF;
END PROCESS;
-----------------------------------------------------
  -- NEXT STATE LOGIC
  nextStateLogic: PROCESS(curState, data_reg)
  BEGIN
     -- assign default values
    start  <= '0';
    rxDone <= '0';
    --rxnow <= '1'; -- equivalent to 'valid'
    txNow  <= '0';
    seqDone <= '0';
   
    -- Assign counter values
    res_dataReadyCount <= '0';
    en_dataReadyCount <= '0';
    en_validCount <= '0';
    res_validCount <= '0';
 
    CASE curState IS
 
      WHEN INIT =>
        IF rxNow = '1' THEN
          nextState <= RECEIVING;
        ELSIF rxNow = '0' THEN
          nextState <= INIT;
      END IF;
   
 
      WHEN RECEIVING =>
        IF data_reg = X"41" OR data_reg = X"61" THEN -- Detects A or a
          nextState <= WAIT_NNN;                     -- waits for NNN to be typed to the terminal
       
        ELSIF data_reg = X"50" OR data_reg = X"70" THEN -- Detects P or p
          nextState <= P_PRINT;
       
        ELSIF data_reg = X"4C" OR data_reg = X"6C" THEN -- Detects L or l
          nextState <= L_PRINT;
       
        ELSE -- If not A, P, or L
          nextState <= INIT;
        END IF;  
       
      WHEN WAIT_NNN =>
        IF rxNow = '1' THEN
          en_validCount = '1';
          nextState <= CHECK_NNN;
        ELSIF rxNow = '0' THEN
          nextState <= WAIT_NNN;
        END IF;
     
      WHEN L_PRINT =>
        IF seqDone = '1' THEN
          FOR i in in 0 to 20 LOOP 
            --L_ARRAY HERE?
            IF txDone = '1' THEN
              txNow = '0';
            ELSIF txDone = '0' THEN
              txData <= L_array(i); 
              txNow = '1';
            END IF;
          END LOOP;
        ELSE
          nextState <= INIT;
        END IF;
      
        
     
      WHEN P_PRINT =>
        IF seqDone = '1' THEN
          FOR i in in 0 to 5 LOOP 
            --P_ARRAY HERE?
            IF txDone = '1' THEN
              txNow = '0';
            ELSIF txDone = '0' THEN
              txData <= P_array(i); 
              txNow = '1';
            END IF;
          END LOOP;
        ELSE
          nextState <= INIT;
        END IF;
    
     
      WHEN CHECK_NNN =>
        IF BOOL_N1 = TRUE OR BOOL_N2 = TRUE THEN
          nextState <= WAIT_NNN;
        ELSE  -- IF N1 OR N2 ARE NOT INTEGERS
          nextState <= INIT;
       
        IF BOOL_N3 = TRUE THEN
          nextState <= START;
        ELSE  -- IF N3 IS NOT AN INTEGER
          nextState <= INIT;

      WHEN START =>
        start = '1'; -- NOTE: start is initialized as 0 hence should only be HIGH for 1 clk cycle
        nextState <= WAIT_BYTES;

      WHEN WAIT_BYTES =>
        IF dataReady = '1' THEN
          nextState <= RECEIVE_BYTES;
        ELSIF dataReady = '0' THEN
          nextState <= WAIT_BYTES;
        END IF;
     
      WHEN RECEIVE_BYTES =>
        en_dataReadyCount = '1';
        nextState <= TRANSMIT_BYTES;
     
      WHEN TRANSMIT_BYTES =>
        IF txDone = '1' THEN
          txNow = '0';
          nextState <= TRANSMIT_BYTES;
        ELSIF txDone = '0' THEN
          txNow = '1';
          nextState <= EQUAL_NNN;
        END IF;
     
      WHEN EQUAL_NNN =>
        IF dataReadyCount = NNN THEN -- NOTE: 'NNN' is not defined yet but it represents the integer value of BCD_numWords (type: array)
          res_dataReadyCount = '1'; -- CHECK MIGHT NEED TO RESET IN NEXT STATE
          nextState <= INIT;   -- GO TO NEXT STATE
        ELSIF dataReadyCount /= NNN THEN -- If its not equal to NNN
          nextState <= WAIT_BYTES;
        END IF;
   
      WHEN OTHERS =>
        nextState <= INIT;  -- Accounts for undefined states
   
    END CASE;
  END PROCESS;
 
  -----------------------------------------------------

  -- NEXTSTATE OUTPUT LOGIC
  ctrlOut: PROCESS(curState, data_reg)
  BEGIN
    -- assign default values
   
    start  <= '0';
    rxDone <= '0';
    --rxnow <= '1'; -- equivalent to 'valid'
    txNow  <= '0';
    seqDone <= '0';

 
    CASE curState IS
     
      WHEN INIT =>
        nextState <= A;
 
      WHEN A =>
        nextState <= ;
     
      WHEN L =>
        nextState <= ;
     
      WHEN P =>
        nextState <= ;
     
      WHEN CHECK_NNN =>
 
 
      WHEN ECHO =>
        nextState <= ;

      WHEN START =>
        nextState <= ;
     
      WHEN PRINT =>
        nextState <= ;
     
      WHEN OTHERS =>
   
   
    END CASE;
END PROCESS;


 
END; -- ARCHITECHTURE

 -----------------------------------------------------
 --P PRINT
 Peak_print: PROCESS()
 BEGIN
   P_array(0)<= L_array(9);
   P_array(1)<= L_array(10);
   P_array(2)<= X"20";
   
   P_array(3)<= '0011' & maxIndex(0);
   P_array(4)<= '0011' & maxIndex(1);
   P_array(5)<= '0011' & maxIndex(2);
END PROCESS;
   
   
