LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
USE work.common_pack.ALL;

ENTITY cmdProc IS
PORT (
    clk:          IN std_logic;
    reset:        IN std_logic;
    rxnow:        IN std_logic;
    rxData:       IN std_logic_vector (7 downto 0); -- Data input
    txData:       OUT std_logic_vector (7 downto 0);
    rxdone:       OUT std_logic;
    ovErr:        IN std_logic;
    framErr:      IN std_logic;
    txnow:        OUT std_logic;
    txdone:       IN std_logic;
    start:        OUT std_logic;
    numWords_bcd: OUT BCD_ARRAY_TYPE(2 downto 0);
    dataReady:    IN std_logic;
    byte:         IN std_logic_vector(7 downto 0);
    maxIndex:     IN BCD_ARRAY_TYPE(2 downto 0);
    dataResults:  IN CHAR_ARRAY_TYPE(0 to RESULT_BYTE_NUM-1);
    seqDone:      IN std_logic
    );
END cmdProc;

ARCHITECTURE command OF cmdProc IS

 -- STATE DECLARATION
 TYPE STATE_TYPE IS (INIT, RECEIVING, CARRIAGE, CARRIAGE_OUT, WAIT_NNN, L_TRANS_1, L_TRANS_2,P_TRANS_1, P_TRANS_2, DATA_ARRAY_1, DATA_ARRAY_2, CHECK_NNN,
 CHECK_N1, CHECK_N2, CHECK_N3, S_START, WAIT_BYTES,WAIT_1, RECEIVE_BYTES, TRANSMIT_BYTE_1,TRANSMIT_BYTE_2,SPACE ,EQUAL_NNN, WAIT_N3);
 
 SIGNAL curState, nextState: state_type;
 -- REGISTER SIGNALS
 SIGNAL rxData_reg: std_logic_vector(7 DOWNTO 0); -- Added signal data_reg for input to remain steady for at least 1 clock cycle
 SIGNAL dataReg: std_logic_vector(7 DOWNTO 0);
 SIGNAL en_dataReg: bit;
 
 -- SIGNAL USED TO ECHO DATA  
 SIGNAL en_echo: bit;
 
 -- COUNTER SIGNALS
 SIGNAL lCounter: integer range 0 to 6;
 SIGNAL en_lCounter, res_lCounter: bit;
 SIGNAL en_count, res_count: bit;
 SIGNAL Count: integer range 0 to 999;
 
 -- SIGNAL TO CHECK FOR NNN
 SIGNAL BOOL_N1, BOOL_N2, BOOL_N3: BOOLEAN := FALSE;
 
 -- ARRAY SIGNALS
 SIGNAL L_array: CHAR_ARRAY_TYPE(0 to 19);
 SIGNAL P_array: CHAR_ARRAY_TYPE(0 to 5);
 SIGNAL dataResults_reg: CHAR_ARRAY_TYPE(0 to 6);
 SIGNAL maxIndex_reg: BCD_ARRAY_TYPE(2 downto 0);
 
 -- DEFINED INTEGER SIGNALS USED IN PROCESSES
 -- PROCESS byteToHex
 SIGNAL byte1, byte2: integer range 0 to 15;
 SIGNAL byteOut1, byteOut2: std_logic_vector(7 DOWNTO 0);
 -- PROCESS dataResToHex
 SIGNAL Res: std_logic_vector(7 DOWNTO 0);
 SIGNAL data1, data2: integer range 0 to 15;
 -- PROCESS NNN_CHECK
 SIGNAL n1, n2, n3: std_logic_vector(7 DOWNTO 0);
 SIGNAL num1, num2, num3: integer range 0 to 9;
 SIGNAL NNN: integer range 0 to 999;
 
BEGIN
-----------------------------------------------------  
  -- REGISTERS
  State_register: PROCESS (reset, clk, rxData)
  BEGIN
    IF reset = '1' THEN
      curState <= INIT;
    ELSIF clk'EVENT AND clk = '1' THEN
      rxData_reg <= rxData;  -- Register used to store rxData
      curState <= nextState;
    ELSE 
      curState <= curState;
    END IF;
  END PROCESS;

  data_register: PROCESS (clk, rxData, en_dataReg)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF en_dataReg = '1' THEN
        dataReg <= rxData;  -- Register used to store:'a', 'A', 'L', 'l', 'P', OR 'p'
      END IF;
    END IF;
  END PROCESS;
 
dataResults_register: PROCESS(clk,seqDone, dataResults,maxIndex)
BEGIN
  IF clk'EVENT AND clk = '1' THEN
    IF seqDone = '1' THEN
      dataResults_reg <= dataResults; -- Stores 'dataResults' when seqDone is high
      maxIndex_reg <= maxIndex;       -- Stores 'maxIndex' when seqDone is high
    END IF;
  END IF;
END PROCESS;
 
-----------------------------------------------------
-- TRANSMISSION FUNCTION
transmitOut: PROCESS (en_echo,curState, clk,txDone, rxData_reg,L_array,P_array, byteOut1,byteOut2)
BEGIN
  IF clk'EVENT AND clk = '1' THEN
    IF txDone = '0' THEN -- If txDone is low
      txNow <= '0';      -- No transmission occurs
   
    ELSIF txDone = '1' THEN  -- If txDone is High
      txnow <= '1';          -- Data gets transmitted if it meets the 'IF conditions' below
      IF en_echo = '1' THEN  -- Responsible for Echoing Data to user
        txData <= rxData_reg;
      ELSIF curState = CARRIAGE OR curState = CARRIAGE_OUT THEN -- Adds a new line (Carriage Return)
        txData <= X"0D";
      ELSIF curState = L_TRANS_1 THEN                           -- prints the list of dataResults (L printing)
         txData <= L_array(Count);
      ELSIF curState = P_TRANS_1 THEN                           -- prints the Peak & its index (P printing)
         txData <= P_array(Count);
      ELSIF curState = SPACE THEN                               -- Adds Spaces
        txData <= X"20";
      ELSIF curState = TRANSMIT_BYTE_1 THEN                     -- Transmits the 1st part of the Byte
        txData <= byteOut1;
      ELSIF curState = TRANSMIT_BYTE_2 THEN                     -- Transmits the 2nd part of the Byte
        txData <= byteOut2;
     
      ELSE            -- If none of the 'IF conditions' are met
        txNow <= '0'; -- No transmission occurs
      END IF;
    END IF;
  END IF;
 
END PROCESS;
-----------------------------------------------------
-- CONVERSIONS
byteToHex: PROCESS(byte1, byte2)
BEGIN
 
  IF(byte1 >= 0) AND (byte1 <= 9) THEN                       -- Checks if the 1st part of the value is a number
    byteOut1 <= std_logic_vector(to_unsigned(byte1 + 48,8)); -- Coverts the number to ASCII format
  ELSIF (byte1 >= 10) AND (byte1 <= 15) THEN                 -- Checks if the 1st part of the value is A,B,C,D,or F
    byteOut1 <= std_logic_vector(to_unsigned(byte1 + 55,8)); -- Coverts A,B,C,D,or F to their ASCII format
  ELSE
    byteOut1 <= "00000000";
  END IF;

  IF (byte2 >= 0) AND (byte2 <= 9) THEN                      -- Checks if the 2nd part of the value is a number
    byteOut2 <= std_logic_vector(to_unsigned(byte2 + 48,8)); -- Coverts the number to ASCII format
  ELSIF (byte2 >= 10) AND (byte2 <= 15) THEN                 -- Checks if the 2nd part of the value is A,B,C,D,or F
    byteOut2 <= std_logic_vector(to_unsigned(byte2 + 55,8)); -- Coverts A,B,C,D,or F to their ASCII format
  ELSE
    byteOut2 <= "00000000";
  END IF;
 
END PROCESS;


-----------------------------------------------------
-- L PRINTING FUNCTION: Creates an array & adds each value from dataResults in ASCII format with spaces in between
dataResToHex: PROCESS(lCounter, data1, data2)
BEGIN    
  IF lCounter /= 0 THEN
    L_array((3*lCounter)-1) <= X"20";                                   -- Adds spaces between every value from dataResults in the array
  ELSE 
    L_array(2) <= X"20";
  END IF;
 
  IF ((data1 >= 0) AND (data1 <= 9)) THEN                               -- Checks if the 1st part of the value is a number
    L_array(3*lCounter) <= std_logic_vector(to_unsigned(data1 + 48,8)); -- Coverts the number to ASCII format and assigns it to L_array as an 8 bit logic vector
  ELSIF ((data1 >= 10) AND (data1 <= 15)) THEN                          -- Checks if the 1st part of the value is A,B,C,D,or F
    L_array(3*lCounter) <= std_logic_vector(to_unsigned(data1 + 55,8)); -- Coverts A,B,C,D,or F to their ASCII format & assigns it to L_array as an 8 bit logic vector
  ELSE 
    L_array(3*lCounter) <= "00000000";
  END IF;
 
  IF ((data2 >= 0) AND (data2 <= 9)) THEN                                 -- Checks if the 2nd part of the value is a number
    L_array(3*lCounter+1) <= std_logic_vector(to_unsigned(data2 + 48,8)); -- Coverts the number to ASCII format and assigns it to L_array as an 8 bit logic vector
  ELSIF ((data2 >= 10) AND (data2 <= 15)) THEN                            -- Checks if the 2nd part of the value is A,B,C,D,or F
    L_array(3*lCounter+1) <= std_logic_vector(to_unsigned(data2 + 55,8)); -- Coverts A,B,C,D,or F to their ASCII format & assigns it to L_array as an 8 bit logic vector
  ELSE 
    L_array(3*lCounter+1) <= "00000000";
  END IF;

END PROCESS;
 
-----------------------------------------------------
-- COUNTERS
L_COUNTER:PROCESS(reset, res_lCounter, en_lCounter, clk) -- Counter used to access each part of L_array
BEGIN
  IF reset = '1' OR res_lCounter = '1' THEN              -- If reset is enabled
    lCounter <= 0;                                       -- Counter is set to 0  
  ELSIF clk'EVENT AND clk = '1' THEN
    IF en_lCounter = '1' THEN                            -- If counter is enabled
      lCounter <= lCounter + 1;                          -- Increments counter
    ELSE                                                 -- If counter is NOT enabled
      lCounter <= lCounter;                              -- Counter holds the same value
    END IF;
  END IF;
END PROCESS;

COUNTER: PROCESS(reset, res_count, en_count, clk)
BEGIN
  IF reset = '1' OR res_count = '1' THEN  -- If reset is enabled
      Count <= 0;                         -- Counter is set to 0
  ELSIF clk'EVENT AND clk = '1' THEN
    IF en_count = '1' THEN                -- If counter is enabled
      Count <= Count + 1;                 -- Increments counter
    ELSE                                  -- If counter is NOT enabled
      Count <= Count;                     -- Counter holds the same value
    END IF;
  END IF;
END PROCESS;

-----------------------------------------------------
NNN_CHECK: PROCESS(n1, n2, n3, clk, num1, num2, num3)
BEGIN
  NNN<= 0;
  BOOL_N1 <= FALSE;
  BOOL_N2 <= FALSE;
  BOOL_N3 <= FALSE;
  numWords_bcd(2) <= "0000";
  numWords_bcd(1) <= "0000";
  numWords_bcd(0) <= "0000";  
  num1 <= 0;
  num2 <= 0;
  num3 <= 0;
  IF n1(7 DOWNTO 4) = "0011" THEN                 -- Checks if the 1st N is a number
    num1 <= to_integer(unsigned(n1(3 DOWNTO 0))); -- Converts logic vector to integer to use arithmetic and check number validity
    IF (num1 >= 0) AND (num1<= 9) THEN            -- Checks if its a number within range 0 to 9
      numWords_bcd(2) <= n1(3 DOWNTO 0);          -- Assigns the 2nd half as its in BCD format to numWords_bcd array
      BOOL_N1 <= TRUE;                            -- If the 1st N is a number it assigns TRUE for BOOL_N1
    ELSE                                          -- If the 1st N is not a number
      BOOL_N1 <= FALSE;                           -- It assigns FALSE for BOOL_N1
      numWords_bcd(2) <= "0000";                  -- Assigns number 0 in BCD to array
    END IF;
  END IF;
     
  IF n2(7 DOWNTO 4) = "0011" THEN                 -- Checks if the 2nd N is a number
    num2 <= to_integer(unsigned(n2(3 DOWNTO 0))); -- Converts logic vector to integer to use arithmetic and check number validity
    IF (num2 >= 0) AND (num2<= 9) THEN            -- Checks if its a number within range 0 to 9
      numWords_bcd(1) <= n2(3 DOWNTO 0);          -- Assigns the 2nd half as its in BCD format to numWords_bcd array
      BOOL_N2 <= TRUE;                            -- If the 2nd N is a number it assigns TRUE for BOOL_N2
    ELSE                                          -- If the 2nd N is not a number
      BOOL_N2 <= FALSE;                           -- It assigns FALSE for BOOL_N2
      numWords_bcd(2) <= "0000";
      numWords_bcd(1) <= "0000";                  -- Assigns number 0 in BCD to array
    END IF;
  END IF;
         
  IF n3(7 DOWNTO 4) = "0011" THEN                 -- Checks if the 3rd N is a number
    num3 <= to_integer(unsigned(n3(3 DOWNTO 0))); -- Converts logic vector to integer to use arithmetic and check number validity
    IF (num3 >= 0) AND (num3<= 9) THEN            -- Checks if its a number within range 0 to 9
      numWords_bcd(0) <= n3(3 DOWNTO 0);          -- Assigns the 2nd half as its in BCD format to numWords_bcd array
      BOOL_N3 <= TRUE;                            -- If the 3rd N is a number it assigns TRUE for BOOL_N3
      NNN <= (num1*100) + (num2*10) + (num3);     -- Positioning all digits (N1,N2,& N3)to the right decimal point  
    ELSE                                          -- If the 3rd N is not a number
      BOOL_N3 <= FALSE;                           -- It assigns FALSE for BOOL_N3
      numWords_bcd(2) <= "0000";
      numWords_bcd(1) <= "0000";
      numWords_bcd(0) <= "0000";                  -- Assigns number 0 in BCD to array
    END IF;
  END IF;
 
END PROCESS;

-----------------------------------------------------
 --P PRINTING FUNCTION
 Peak_print: PROCESS(L_array, maxIndex_reg)
 BEGIN
   P_array(0)<= L_array(9);               -- Adding peak to the array
   P_array(1)<= L_array(10);
   P_array(2)<= X"20";                    -- Adding space to the array between peak value and maxIndex
   
   P_array(3)<= "0011" & maxIndex_reg(2); -- Adding Max index in ASCII format
   P_array(4)<= "0011" & maxIndex_reg(1);
   P_array(5)<= "0011" & maxIndex_reg(0);
END PROCESS;

-----------------------------------------------------

 
 
  -- NEXT STATE LOGIC
  nextStateLogic: PROCESS(curState, rxData_reg, rxNow, txDone, BOOL_N1, BOOL_N2, BOOL_N3, byte,dataReady,NNN,lCounter, dataResults_reg, dataReg, Res)
  BEGIN
     -- Assign default values
    start  <= '0';
    rxDone <= '0';
    en_echo <= '0';
    en_dataReg <= '0';
    -- Assign counter values
    en_lCounter <= '0';
    res_lCounter <= '0';
    en_count <= '0';
    res_count <= '0';
   
    CASE curState IS
 
      WHEN INIT =>
        res_count <= '1';         -- Main Counter is reset to zero
        IF rxNow = '1' THEN       -- If data is outputted from Rx
          rxDone <= '1';          -- States that data has been received from Rx
          nextState <= RECEIVING; -- Then go to the 'RECEIVING' state
        ELSIF rxNow = '0' THEN    -- If no data is outputted from Rx  
          nextState <= INIT;      -- Remain in inital state
        ELSE
          nextState <= INIT;
        END IF;
     
      WHEN RECEIVING =>
        en_echo <= '1';                                  -- Enabling echo to echo any received input data
        IF rxData_reg = X"41" OR rxData_reg = X"61" THEN -- Detects A or a in ASCII
          en_dataReg <= '1';                             -- Register is enabled to store A or a
          nextState <= WAIT_NNN;                         -- If A or a is detected then go to 'WAIT_NNN' state
        ELSIF rxData_reg = X"50" OR rxData_reg = X"70" OR rxData_reg = X"4C" OR rxData_reg = X"6C" THEN -- Detects P or p or L or l
          en_dataReg <= '1';                             -- Register is enabled to store P or p or L or l
          nextState <= CARRIAGE;                         -- If P or p or L or l detected then go to 'CARRIAGE' state to go to a new line after echoing them
        ELSE                                             -- IF NOT P or p, L or l, A or a
          nextState <= INIT;                             -- Go back to initial state
        END IF;

    WHEN CARRIAGE =>                                                                     -- State adds a new line
      res_count <= '1';                                                                  -- Main Counter is reset to zero
      IF txDone = '0' THEN                                                               -- If a new line is NOT added
        nextState <= CARRIAGE;                                                           -- Remain in 'CARRIAGE' state to add a new line
      ELSIF txDone = '1' THEN                                                            -- If new line has been added
        IF dataReg = X"50" OR dataReg = X"70" OR dataReg = X"4C" OR dataReg = X"6C" THEN -- If P or p or L or l has been recieved/requested  
          nextState <= DATA_ARRAY_1;                                                     -- Then go to 'DATA_ARRAY_1' state
        ELSIF BOOL_N3 = TRUE THEN                                                        -- If ANNN or aNNN is received/detected
          nextState <= S_START;  
        ELSE
          nextState <= INIT;                                                        -- Then go to 'S_START' state to request NNN bytes from dataPro
        END IF;
      END IF;
     
       
      WHEN WAIT_NNN =>            -- State receives NNN
        IF rxNow = '1' THEN       -- If data is outputted from Rx
          rxDone <= '1';          -- State that data has been received from Rx
          en_count <= '1';        -- Increment Main Counter
          nextState <= CHECK_NNN; -- Then go to 'CHECK_NNN' state to check if 3 bytes have been recieved
        ELSIF rxNow = '0' THEN    -- If no data is outputted from Rx
          nextState <= WAIT_NNN;  -- Remain in 'WAIT_NNN' state to receive a byte from Rx
        ELSE
          nextState <= INIT;
        END IF;
     
      WHEN CHECK_NNN =>           -- State checks if 3 numbers have been recieved
        IF Count = 1 THEN         -- If Main Counter is equal to 1
          n1 <= rxData_reg;           -- Assign the 1st byte to signal n1
          nextState <= CHECK_N1;  -- Then go to 'CHECK_N1' state to check if 1st byte is a number
        ELSIF Count = 2 THEN      -- If Main Counter is equal to 2
          n2 <= rxData_reg;           -- Assign the 2nd byte to signal n2
          nextState <= CHECK_N2;  -- Then go to 'CHECK_N2' state to check if 2nd byte is a number
        ELSIF Count = 3 THEN      -- If Main Counter is equal to 3
          n3 <= rxData_reg;           -- Assign the 3rd byte to signal n3
          nextState <= CHECK_N3;  -- Then go to 'CHECK_N3' state to check if 3rd byte is a number
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN CHECK_N1 =>             -- State checks if 1st byte is a number
        en_echo <= '1';            -- Enabling echo to echo received byte
        IF BOOL_N1 = TRUE THEN     -- If 1st byte is a number
          nextState <= WAIT_NNN;   -- Then go to 'WAIT_NNN' to receive 2nd byte (i.e., N2)
        ELSIF BOOL_N1 = FALSE THEN -- If 1st byte is NOT a number
          nextState <= INIT;       -- Then go back to initial state
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN CHECK_N2 =>             -- State checks if 2nd byte is a number
        en_echo <= '1';            -- Enabling echo to echo received byte
        IF BOOL_N2 = TRUE THEN     -- If 2nd byte is a number
          nextState <= WAIT_NNN;   -- Then go to 'WAIT_NNN' to receive 3rd byte (i.e., N3)
        ELSIF BOOL_N2 = FALSE THEN -- If 2nd byte is NOT a number
          nextState <= INIT;       -- Then go back to initial state
        ELSE
          nextState <= INIT;
        END IF;
         
      WHEN CHECK_N3 =>             -- State checks if 3rd byte is a number
        en_echo <= '1';            -- Enabling echo to echo received byte
        IF BOOL_N3 = TRUE THEN     -- If 3rd byte is a number
          en_dataReg <= '1';       -- Register is enabled to store 3rd number (N3)
          nextState <= WAIT_N3;   -- Then go to 'CARRIAGE' state to go to a new line after echoing ANNN or aNNN
        ELSIF BOOL_N3 = FALSE THEN -- If 3rd byte is NOT a number
          nextState <= INIT;       -- Then go back to initial state
        ELSE
          nextState <= INIT;
        END IF;
         
       WHEN WAIT_N3 =>
          IF BOOL_N3 = TRUE THEN 
            nextState <= CARRIAGE; 
          ELSE 
            nextState <= WAIT_N3;
          END IF;
          
      WHEN DATA_ARRAY_1=>                   -- State indexes array and stores each byte from dataResults in signal Res
          Res <= dataResults_reg(lCounter);
          nextState <= DATA_ARRAY_2;

       
      WHEN DATA_ARRAY_2 =>
        data1 <= to_integer(unsigned(Res(7 downto 4)));       -- Stores 4 MSB in signal data1
        data2 <= to_integer(unsigned(Res(3 downto 0)));       -- Stores 4 LSB in signal data2
        IF lCounter /= 6 THEN                                 -- If list Counter is NOT equal to 6                      
          en_lCounter <= '1';                                 -- Enable list Counter
          nextState <= DATA_ARRAY_1;                          -- Then go to 'DATA_ARRAY_1' state to index next byte in dataResults
        ELSIF lCounter = 6 THEN                               -- If list Counter is equal to 6  
          --IF rxData_reg = X"4C" OR rxData_reg = X"6C" THEN    -- If L or l is detected
            nextState <= L_TRANS_1;                           -- Go to 'L_TRANS_1' state to transmit list (print L)
          --ELSIF rxData_reg = X"50" OR rxData_reg = X"70" THEN -- If P or p is detected
            --nextState <= P_TRANS_1;                           -- Go to 'P_TRANS_1' state to transmit peak & its index (print P)
          --END IF;
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN L_TRANS_1 =>
        IF txDone = '0' THEN      -- If data has not been transmitted
          nextState <= L_TRANS_1; -- Remain in 'L_TRANS_1' state
        ELSIF txDone = '1' THEN   -- If data is successfully transmitted
          nextState <= L_TRANS_2; -- Go to 'L_TRANS_2' to transmit next part of list
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN L_TRANS_2 =>
        IF Count /= 19 THEN          -- If counter is NOT equal to 19 (L_Array size)
          en_count <= '1';           -- Increment Main Counter  
          nextState <= L_TRANS_1;    -- Then go back to 'L_TRANS_1' to transmit list (i.e,print L)
        ELSIF Count = 19 THEN        -- If counter is equal to 19
          nextState <= CARRIAGE_OUT; -- Then go to 'CARRIAGE_OUT' state to add a new line
        ELSE
          nextState <= INIT;
        END IF;
         
      WHEN CARRIAGE_OUT =>           -- State adds a new line
        IF txDone = '0' THEN         -- If a new line is NOT added
          nextState <= CARRIAGE_OUT; -- Remain in 'CARRIAGE_OUT' state to add a new line
        ELSIF txDone = '1' THEN      -- If new line has been added  
          nextState <= INIT;         -- Go back to initial state
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN P_TRANS_1 =>  
        IF txDone = '0' THEN      -- If data has not been transmitted
          nextState <= P_TRANS_1; -- Remain in 'P_TRANS_1' state
        ELSIF txDone = '1' THEN   -- If data is successfully transmitted
          nextState <= P_TRANS_2; -- Go to 'P_TRANS_2' to transmit next part of list
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN P_TRANS_2 =>
        IF Count /= 5 THEN           -- If counter is NOT equal to 5 (P_Array size)
          en_count <= '1';           -- Incremment Main Counter
          nextState <= P_TRANS_1;    -- Then go back to 'P_TRANS_1' to transmit peak & its Index (i.e,print P)
        ELSIF Count = 5 THEN         -- If counter is equal to 5
          nextState <= CARRIAGE_OUT; -- Then go to 'CARRIAGE_OUT' state to add a new line
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN S_START =>
        start <= '1';            -- Signals dataPro that cmdPro is ready to receive requested number of bytes
        nextState <= WAIT_BYTES; -- Then go to 'WAIT_BYTES' state

      WHEN WAIT_BYTES =>              -- State waits for bytes from data Processor
        IF dataReady = '1' THEN       -- If byte is ready to be received from data processor
          en_count <= '1';            -- enable Main Counter
          nextState <= RECEIVE_BYTES; -- Then go to 'RECEIVE_BYTES' state to get each byte ready for transmission
        ELSIF dataReady = '0' THEN    -- If byte is NOT ready to be received from data processor
          nextState <= WAIT_BYTES;    -- Remain in 'WAIT_BYTES' state
        ELSE
          nextState <= INIT;
        END IF;

      WHEN RECEIVE_BYTES =>                  
        byte1 <= to_integer(unsigned(byte(7 DOWNTO 4))); -- Stores 4 MSB in signal byte1  
        byte2 <= to_integer(unsigned(byte(3 DOWNTO 0))); -- Stores 4 LSB in signal byte2
        IF txDone = '1' THEN                             -- If data is successfully transmitted
          nextState <= TRANSMIT_BYTE_1;                  -- Go to 'TRANSMIT_BYTE_1' state to transmit the 1st byte
        ELSIF txDone = '0' THEN                          -- If data has not been transmitted
          nextState <= RECEIVE_BYTES;                    -- Remain in 'RECEIVE_BYTES' state
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN TRANSMIT_BYTE_1 =>           -- State Transmits the 1st byte
        IF txDone = '1' THEN            -- If txDone is still high
          nextState <= TRANSMIT_BYTE_1; -- Remain in 'TRANSMIT_BYTE_1' state
        ELSIF txDone = '0' THEN         -- If txDone is low and the 1st byte has been transmitted
          nextState <= WAIT_1;          -- Go to 'WAIT_1' state
        ELSE
          nextState <= INIT;
        END IF;

      WHEN WAIT_1 =>                    -- State waits for 1st byte to be successfully transmitted to transmit 2nd byte  
        IF txDone = '1' THEN            -- If 1st byte has been successfully transmitted
          nextState <= TRANSMIT_BYTE_2; -- Go to 'TRANSMIT_BYTE_2' state to transmit 2nd byte
        ELSE
          nextState <= WAIT_1;
        END IF;
     
      WHEN TRANSMIT_BYTE_2 =>           -- State Transmits the 2nd byte
        IF txDone = '1' THEN            -- If txDone is still high
          nextState <= TRANSMIT_BYTE_2; -- Remain in 'TRANSMIT_BYTE_2' state
        ELSIF txDone = '0' THEN         -- If txDone is low and the 2nd byte has been transmitted
          nextState <= SPACE;           -- Go to 'SPACE' state to add a space before transmitting the next byte
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN SPACE =>               -- State adds spaces between bytes transmitted  
        IF txDone = '0' THEN      -- If space is NOT added/transmitted
          nextState <= SPACE;     -- Remain in 'SPACE' state to add/transmit space
        ELSIF txDone = '1' THEN   -- If space is added/transmitted
          nextState <= EQUAL_NNN; -- go to 'EQUAL_NNN' to chack if all requested bytes have been transmitted
        ELSE
          nextState <= INIT;
        END IF;
       
      WHEN EQUAL_NNN =>      
        IF Count = NNN THEN      -- If bytes transmitted are equal to NNN
          res_count <= '1';      -- Main Counter is reset to zero
          nextState <= DATA_ARRAY_1;     -- Then go back to initial state
        ELSIF Count /= NNN THEN  -- If bytes transmitted are NOT equal to NNN
          nextState <= S_START;  -- Go back to 'S_START' state to receive rest of requested bytes
        ELSE
          nextState <= INIT;
        END IF;
   
      WHEN OTHERS =>
        nextState <= INIT;  -- Accounts for undefined states
   
    END CASE;
  END PROCESS;
END;
  -----------------------------------------------------
-- WRITE IMPROVEMENT SECTION ON REPORT:
-- TO IMPROVE OUR CODE, WE COULD HAVE SEPARATED OUR COMBINATIONAL LOGIC
-- FROM OUR OUTPUT LOGIC IN A DIFFERENT PROCESS (BECAUSE IT IS GOOD PRACTICE)
