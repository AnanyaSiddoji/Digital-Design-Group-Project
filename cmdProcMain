LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
USE work.common_pack.ALL;
-- NOTES:
-- data_reg is not assigned to rxData (ASK TA IF ITS IMPLEMENTED CORRECTLY !!!)
--
ENTITY cmdProc IS
PORT (
    clk:          IN std_logic;
    reset:        IN std_logic;
    rxnow:        IN std_logic;
    rxData:       IN std_logic_vector (7 downto 0); -- Data input
    txData:       OUT std_logic_vector (7 downto 0);
    rxdone:       OUT std_logic;
    ovErr:        IN std_logic;
    framErr:      IN std_logic;
    txnow:        OUT std_logic;
    txdone:       IN std_logic;
    start:        OUT std_logic;
    numWords_bcd: OUT BCD_ARRAY_TYPE(2 downto 0);
    dataReady:    IN std_logic;
    byte:         IN std_logic_vector(7 downto 0);
    maxIndex:     IN BCD_ARRAY_TYPE(2 downto 0);
    dataResults:  IN CHAR_ARRAY_TYPE(0 to RESULT_BYTE_NUM-1);
    seqDone:      IN std_logic
    );
END cmdProc;

ARCHITECTURE command OF cmdProc IS
 
 -- STATE DECLARATION
 TYPE STATE_TYPE IS (INIT, RECEIVING,WAIT_NNN, L, P, CHECK_NNN, ECHO, START, PRINT);
 SIGNAL curState, nextState: state_type;
 SIGNAL data_reg: std_logic_vector(7 DOWNTO 0); -- Added signal data_reg for input to remain steady for at least 1 clock cycle
 
 -- COUNTER SIGNALS  
 SIGNAL validCount: integer range 0 to 3;
 SIGNAL en_validCount, res_validCount: bit;  
 
 -- SIGNAL TO CHECK FOR NNN
 SIGNAL BOOL_N1, BOOL_N2, BOOL_N3: BOOLEAN := FALSE;

-----------------------------------------------------  
  -- STATE REGISTERS
  State_register: PROCESS (reset, clk)
  BEGIN
    IF reset = '1' THEN
      curState <= INIT;
    ELSIF clk'EVENT AND clk = '1' THEN
      data_reg <= rxData;  
      curState <= nextState;
    END IF;
  END PROCESS;
-----------------------------------------------------
-- CONVERSIONS
byteToHex: PROCESS(byte)
BEGIN
  byte1 <= to_integer(unsigned(byte(7 DOWNTO 4)));
  byte2 <= to_integer(unsigned(byte(3 DOWNTO 0)));
   
  IF ((byte1 >= 0) OR ((byte2 >= 0) AND (byte1 <= 9)) OR (byte2 <= 9)) THEN
    byteOut1 <= '0011' & byte(7 DOWNTO 4);
    byteOut2 <= '0011' & byte(3 DOWNTO 0);

  ELSIF (byte1 >= 10) OR ((byte2 >= 10) AND (byte1 <= 15)) OR ((byte2 >= 15) THEN
    byteOut1 <= '0100' & byte(7 DOWNTO 4);  -- A, B, C, D, E, F
    byteOut2 <= '0100' & byte(3 DOWNTO 0);  -- A, B, C, D, E, F

  END IF;
 
END PROCESS;
 
-----------------------------------------------------
-- COUNTERS
NNN_counter: PROCESS(reset, res_validCount, en_validCount, clk, rxnow)
BEGIN
  IF reset = '1' OR res_validCount = '1' THEN
      validCount <= 0;
 
  ELSIF clk'EVENT AND clk = '1' THEN
    IF en_validCount = '1' AND curState = WAIT_NNN THEN
      IF rxnow = '1' THEN
        validCount <= validCount + 1;
      ELSE
        validCount <= validCount;
      END IF;
    END IF;
  END IF;
END PROCESS;
-----------------------------------------------------
NNN_CHECK: PROCESS(validCount, clk)
BEGIN
  IF validCount = 1 THEN
    n1 <= data_reg;
  ELSIF validCount = 2 THEN
    n2 <= data_reg;
  ELSIF validCount = 3 THEN
    n3 <= data_reg;
  END IF;
     
  IF n1(7 DOWNTO 4) = '0011' AND n2(7 DOWNTO 4) = '0011' AND n3(7 DOWNTO 4) = '0011' THEN
    num1 <= to_integer(n1(3 DOWNTO 0));
    num2 <= to_integer(n2(3 DOWNTO 0));
    num3 <= to_integer(n3(3 DOWNTO 0));
       
    IF (num1 >= 0) AND (num2>= 0) AND (num3 >= 0) AND (num1<= 9) AND (num2<= 9) AND (num3<= 9) THEN
      numWords_bcd(0) <= n1(3 DOWNTO 0);
      numWords_bcd(1) <= n2(3 DOWNTO 0);
      numWords_bcd(2) <= n3(3 DOWNTO 0);
      BOOL_N1 <= TRUE; 
      BOOL_N2 <= TRUE;
      BOOL_N3 <= TRUE;
      
    ELSE
      numWords_bcd(0) <= "0000";
      numWords_bcd(1) <= "0000";
      numWords_bcd(2) <= "0000";
      BOOL_N1 <= FALSE; 
      BOOL_N2 <= FALSE;
      BOOL_N3 <= FALSE;
      nextState <= INIT; -- REMOVE 
  ELSE
    numWords_bcd(0) <= "0000";
    numWords_bcd(1) <= "0000";
    numWords_bcd(2) <= "0000";
    BOOL_N1 <= FALSE; 
    BOOL_N2 <= FALSE;
    BOOL_N3 <= FALSE;
    nextState <= INIT; -- REMOVE 
     
    END IF;
  END IF;
END PROCESS;

-----------------------------------------------------
  -- NEXT STATE LOGIC
  nextStateLogic: PROCESS(curState, data_reg)
  BEGIN
 
    CASE curState IS
 
      WHEN INIT =>
        IF rxNow = '1' THEN
          nextState <= RECEIVING;
        ELSIF rxNow = '0' THEN
          nextState <= INIT;
      END IF;
         
 
      WHEN RECEIVING =>
        IF data_reg = X"41" OR data_reg = X"61" THEN -- Detects A or a
          nextState <= WAIT_NNN;                            -- waits for NNN to be typed to the terminal
       
        ELSIF data_reg = X"50" OR data_reg = X"70" THEN -- Detects P or p
          nextState <= P;
       
        ELSIF data_reg = X"4C" OR data_reg = X"6C" THEN -- Detects L or l
          nextState <= L;
       
        ELSE -- If not A, P, or L
          nextState <= INIT;
        END IF;  
       
      WHEN WAIT_NNN =>
        en_validCount = '0';
        IF rxNow = '1' THEN
          en_validCount = '1';
          nextState <= CHECK_NNN;
        ELSIF rxNow = '0' THEN
          nextState <= WAIT_NNN;
        END IF;
     
      WHEN L_PRINT =>
        nextState <= ECHO;
     
      WHEN P_PRINT =>
        nextState <= ECHO;
     
      WHEN CHECK_NNN =>
        en_validCount = '0';
        IF BOOL_N1 = TRUE OR BOOL_N2 = TRUE THEN
          nextState <= WAIT_NNN;
        ELSE 
          nextState <= INIT;
        
        IF BOOL_N3 = TRUE THEN
          nextState <= ; -- ADD NEXT STATE 
        ELSE 
          nextState <= INIT;
 
      WHEN ECHO =>
        nextState <= ;

      WHEN START =>
        nextState <= ;
     
      WHEN PRINT =>
        nextState <= ;
   
      WHEN OTHERS =>
        nextState <= INIT;  -- Accounts for undefined states
   
    END CASE;
  END PROCESS;
 
  -----------------------------------------------------

  -- NEXTSTATE OUTPUT LOGIC
  ctrlOut: PROCESS(curState, data_reg)
  BEGIN
    -- assign default values
   
    start  <= '0';
    rxDone <= '0';
    rxnow <= '1'; -- equivalent to 'valid'
    txNow  <= '0';
    txdone <= '1';
    seqDone <= '0';
    dataReady <= '1';
 
    CASE curState IS
     
      WHEN INIT =>
        nextState <= A;
 
      WHEN A =>
        nextState <= ;
     
      WHEN L =>
        nextState <= ;
     
      WHEN P =>
        nextState <= ;
     
      WHEN CHECK_NNN =>
 
 
      WHEN ECHO =>
        nextState <= ;

      WHEN START =>
        nextState <= ;
     
      WHEN PRINT =>
        nextState <= ;
     
      WHEN OTHERS =>
   
   
    END CASE;
END PROCESS;


 
END; -- ARCHITECHTURE
     
     


